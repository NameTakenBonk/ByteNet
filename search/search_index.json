{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"simple buffer-based networking <p>         In ByteNet, you don't need to worry about type validation, optimization, packet structure, etc. ByteNet does all the hard parts for you! Strictly typed with an incredibly basic API that explains itself, ByteNet makes networking simple, easy, and quick.     </p> Getting started Download <p> <p> practical example of a packet's definition </p> packets.luau<pre><code>local ByteNet = require(path.to.ByteNet)\n\nreturn ByteNet.defineNamespace(\"example\", function()\n    return {\n        vectorStringMap = ByteNet.definePacket({\n            value = ByteNet.dataTypes.map(ByteNet.dataTypes.vec3(), ByteNet.dataTypes.string())\n        })\n    }\nend)\n</code></pre> </p> <p> example of sending a packet to all clients </p> server.luau<pre><code>local packets = require(path.to.packets)\n\npackets.myPacket.sendToAll({\n    [Vector3.new(1, 1, 1)] = \"10x less bandwidth than a remote!\",\n    [Vector3.new(1, 2, 1)] = \"oh wait, its way more than 10x less.\",\n\n    [Vector3.new(2, 1, 1)] = \"depending on how you use your data,\",\n    [Vector3.new(1, 1, 2)] = \"it could be 100x less!\",\n})\n</code></pre> Not enough? here's more No more RemoteEvents ByteNet handles all instances for you; you don't need to worry about reliability type, parenting, etc   - As low-level as you can get ByteNet lets you directly read/write data types such as uint32, buffers, in a way where the keys are abstracted away. Reap the benefits of a structured, strictly typed library, while retaining the benefits of hardcore optimization."},{"location":"api/dataTypes/Primitives/","title":"Primitives","text":"<p>ByteNet provides a large amount of \"primitive\" types for you to build more complex types that suit your game. Since primitive types don't need any parameters, you can just access them like the following: <code>ByteNet.&lt;typename&gt;</code>. For building more complex data structures, go look at the Specials page.</p>"},{"location":"api/dataTypes/Primitives/#available-primitive-types","title":"Available primitive types","text":""},{"location":"api/dataTypes/Primitives/#supported-general-types","title":"Supported general types","text":"<ul> <li><code>string</code>: String</li> <li><code>buff</code>: Buffer</li> <li><code>bool</code>: Boolean</li> <li><code>nothing</code>: Nothing</li> <li><code>unknown</code>: Any type</li> </ul>"},{"location":"api/dataTypes/Primitives/#supported-number-types","title":"Supported number types","text":"<ul> <li><code>uint8</code>: Unsigned 8-bit integer</li> <li><code>uint16</code>: Unsigned 16-bit integer</li> <li><code>uint32</code>: Unsigned 32-bit integer</li> <li><code>int8</code>: Signed 8-bit integer</li> <li><code>int16</code>: Signed 16-bit integer</li> <li><code>int32</code>: Signed 32-bit integer</li> <li><code>float32</code>: Standard 32-bit float</li> <li><code>float64</code>: Standard 64-bit float</li> </ul>"},{"location":"api/dataTypes/Primitives/#supported-roblox-types","title":"Supported Roblox types","text":"<ul> <li><code>cframe</code>: CoordinateFrame</li> <li><code>vec2</code>: Vector2</li> <li><code>vec3</code>: Vector3</li> <li><code>inst</code>: Instance</li> </ul>"},{"location":"api/dataTypes/Specials/","title":"Specials","text":"<p>Special types are how complex packet types are made. They can take in nearly any type, including themselves, and most importantly they are dynamic. This means you can have an array of any length, a map of any key type and any value type, and an optional value of any type.</p> <p>Special types always take parameters. You have to call them: <code>ByteNet.&lt;type name&gt;(&lt;any primitive type&gt;)</code>.</p> <p>Danger</p> <ul> <li>Using these types incurs 1-2 bytes of overhead due to the dynamic nature.</li> <li>They take drastically more time to parse</li> <li>They are heavier on memory usage, as a new closure is created each time. You will never have to worry about this unless you have dozens of packets, though.</li> </ul>"},{"location":"api/dataTypes/Specials/#available-special-types","title":"Available special types","text":""},{"location":"api/dataTypes/Specials/#structs","title":"Structs","text":"<p>Structs let you send structured data in the form of dictionaries. The fields are optimized away, so they don't take any bandwidth. Structs are how you'll be sending most of your data likely: they are the best for organization, and they let you do really interesting things. For example: chunkPackets.luau<pre><code>return ByteNet.defineNamespace(\"chunks\", function()\n    local chunkData = ByteNet.struct({\n        biome = ByteNet.uint8,\n        seed = ByteNet.int32,\n    })\n\n    return {\n        sendChunks = ByteNet.definePacket({\n            value = ByteNet.array(chunkData)\n        })\n    }\nend)\n</code></pre></p>"},{"location":"api/dataTypes/Specials/#optionals","title":"Optionals","text":"<p>Optional types are a cool name for the concept of \"This doesn't have to exist\". It's good for optional parameters: for example if some invoked function were to fail, you might want to send back a blank copy to indicate that something is wrong.</p> <p>packets.luau<pre><code>return ByteNet.defineNamespace(\"chunks\", function()\n    return {\n        myCoolPacket = ByteNet.definePacket({\n            value = ByteNet.struct({\n                -- An \"optional\" type takes in a parameter.\n                -- This can be anything! You can even have optional arrays.\n                helloWorldString = ByteNet.optional(ByteNet.string)\n\n                -- This works!\n                eachCharacter = ByteNet.optional(ByteNet.array(ByteNet.string))\n            }),\n        })\n    }\nend)\n</code></pre> You really don't have to think about using optional types. You just send it! server.luau<pre><code>local packets = require(path.to.packets)\n\nlocal randomlyStringOrNil = \n    if math.random(1, 2) == 1 then \"Hello, world!\" else nil\n\npackets.myCoolPacket.sendToAll({\n    helloWorldString = randomlyAppearingString,\n\n    -- Note that even if we don't put the \"eachCharacter\" field here,\n    -- it won't error. This is because it's optional!\n})\n</code></pre></p>"},{"location":"api/dataTypes/Specials/#arrays","title":"Arrays","text":"<p>Arrays are fairly self explanatory. They're just plain old arrays. However, it's important to note that mixed tables have undefined behavior when passed as an array. This means things might be missing when they come out on the other side!</p> <p>There is a 2 byte overhead to sending an array in ByteNet. This is because these 2 bytes are an unsigned 16-bit integer, which stores the array length. As a side effect, arrays sent through ByteNet have a max length of 2^16, which is equal to 65,536. It's likely that in the future, you will be able to reduce the overhead to 1 byte through configuration, in turn reducing the max length of the array.</p> packets.luau<pre><code>return ByteNet.defineNamespace(\"example\", function()\n    return {\n        myCoolPacket = ByteNet.definePacket({\n            value = ByteNet.array(ByteNet.bool),\n        })\n    }\n}\n</code></pre> server.luau<pre><code>local packets = require(path.to.packets)\n\npackets.myCoolPacket.sendToAll({\n    -- Important to note that mixed arrays/arrays with holes\n    -- shouldn't be sent through.\n    true, false, true\n})\n</code></pre>"},{"location":"api/dataTypes/Specials/#maps","title":"Maps","text":"<p>Maps are by far the most powerful \"special\" type in ByteNet. They let you send, what's most commonly referred to as a dictionary, through ByteNet. However it's important to keep in mind two things: the type of the key (or index), and the type of the value, cannot change.</p> <p>Like arrays, maps have a 2-byte overhead to store the length of the map. This is done by iterating over the map using generic iteration and increasing a variable by 1 for every key-value pair. This, once again, means that there is a 2^16 (which equals to 65,536) cap to the number of elements in the map.</p> packets.luau<pre><code>return ByteNet.defineNamespace(\"example\", function()\n    return {\n        people = ByteNet.definePacket({\n            -- [name] = age\n            value = ByteNet.map(ByteNet.string, ByteNet.uint8)\n        })\n    }\nend)\n</code></pre> server.luau<pre><code>local packets = require(path.to.packets)\n\npackets.myCoolPacket.sendToAll({\n    john = 21,\n    jane = 24,\n    dave = 26,\n    you = 162,\n})\n</code></pre>"},{"location":"api/functions/definePacket/","title":"definePacket","text":"Defining a packet"},{"location":"api/functions/definePacket/#what-even-is-a-packet-in-bytenet-anyway","title":"what even is a packet in ByteNet anyway?","text":"<p>Packets are the structured dictionaries you use to define the \"format\" your data is going to be sent in. These are named packets as you 'send' packets through network, and packets have their contents usually formatted in a specific way because, well they have to be. </p> <p>ByteNet's purpose as a library is to provide a way to structure your data, and send that structure in a hyper-optimized way.</p>"},{"location":"api/functions/definePacket/#okay-where-do-i-start","title":"Okay, where do I start?","text":"<p>Enough of how it works, let's start off with making a basic packet. We will also need to create a namespace: packets.luau<pre><code>local ByteNet = require(path.to.bytenet)\n\nreturn ByteNet.defineNamespace(\"messaging\", function()\n    return {\n        printSomething = ByteNet.definePacket({\n        -- This value field is very important!\n            value = ByteNet.struct({\n                message = ByteNet.string,\n            })\n        })\n    }\nend)\n</code></pre></p>"},{"location":"api/functions/definePacket/#sending","title":"Sending","text":"<p>On the server, there are 3 methods of sending packets to players. It's important to note that when a player should be specified, it's the second parameter given, not the first. This is an intentional design choice.</p> <ul> <li><code>sendToAll</code></li> <li><code>sendToAllExcept</code></li> <li><code>sendTo</code></li> </ul> <p>On the client, there is only one, because you can only send data to the server:</p> <ul> <li><code>send</code></li> </ul> <p>Any data passed through these functions must obey your structure created in <code>definePacket</code>, and if you have strict typing on, an error will be raised if the types do not match.</p> <p>code examples client.luau<pre><code>-- Sending to server\npackets.myPacket.send({\n    message = \"Hello, world!\"\n})\n</code></pre> server.luau<pre><code>-- Sending to all players\npackets.myPacket.sendToAll({\n    message = \"Hello, players!\"\n})\n\n-- Sending to an individual player\nlocal someArbitraryPlayer = Players.You\n\npackets.myPacket.sendTo({\n    message = \"Hello, random player!\"\n}, someArbitraryPlayer)\n\n-- Sending to all except a certain player\nlocal someArbitraryPlayer = Players.You\n\npackets.myPacket.sendToAllExcept({\n    message = \"Hello, everyone except one person!\"\n}, someArbitraryPlayer)\n</code></pre></p>"},{"location":"api/functions/definePacket/#receiving","title":"Receiving","text":"<p>You can use the <code>listen</code> method to listen for when a packet is received.</p> <p>code examples server.luau<pre><code>packets.myPacket.listen(function(data, player)\n    print(`{player.UserId} says { data.message }`)\nend)\n</code></pre> client.luau<pre><code>packets.myPacket.listen(function(data)\n    print(`server says { data.message }`)\nend)\n</code></pre></p>"},{"location":"api/functions/definePacket/#configuration-reliability-types","title":"Configuration (Reliability types)","text":"<p>Currently, the only config accessible right now is reliability types. This will change as time goes on, however right now, you can switch reliability types by defining <code>reliabilityType</code> to be <code>\"reliable\"</code> or <code>\"unreliable\"</code>.</p>"}]}